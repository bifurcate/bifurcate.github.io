<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Electric Field Flow Visualization</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
        }
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            color: #fff;
            min-width: 300px;
            max-height: 90vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        #controls.hidden {
            transform: translateX(-100%);
        }
        #menu-toggle {
            position: absolute;
            top: 20px;
            left: 340px;
            background: rgba(79, 195, 247, 0.9);
            border: none;
            color: #000;
            width: 40px;
            height: 40px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            transition: left 0.3s ease;
            z-index: 1000;
        }
        #menu-toggle:hover {
            background: rgba(79, 195, 247, 1);
        }
        #menu-toggle.controls-hidden {
            left: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
        }
        input[type="range"], input[type="number"] {
            width: 100%;
        }
        input[type="number"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(79, 195, 247, 0.3);
            color: white;
            padding: 5px;
            border-radius: 4px;
        }
        .value-display {
            display: inline-block;
            margin-left: 10px;
            color: #4fc3f7;
            font-weight: bold;
        }
        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: #4fc3f7;
            border: none;
            border-radius: 5px;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #81d4fa;
        }
        button.danger {
            background: #f44336;
            color: white;
        }
        button.danger:hover {
            background: #e57373;
        }
        .charge-section {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border-left: 4px solid;
        }
        .charge-section h4 {
            margin: 0 0 10px 0;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .charge-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }
        #global-controls {
            background: rgba(79, 195, 247, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid rgba(79, 195, 247, 0.3);
        }
        #global-controls h3 {
            margin-top: 0;
            color: #4fc3f7;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
        }
        .section-title {
            color: #4fc3f7;
            margin: 20px 0 10px 0;
            font-size: 15px;
            font-weight: bold;
        }
        .coordinate-input {
            display: flex;
            gap: 5px;
            margin-top: 5px;
        }
        .coordinate-input input {
            width: 30%;
        }
        .coordinate-input label {
            font-size: 11px;
            margin: 0;
        }
        .small-button {
            padding: 5px 10px;
            font-size: 12px;
            margin-top: 5px;
        }
        #mode-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(79, 195, 247, 0.9);
            padding: 15px 20px;
            border-radius: 8px;
            color: #000;
            font-weight: bold;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <button id="menu-toggle">☰</button>
    <div id="mode-indicator">Ctrl+Click to place charges</div>
    <div id="controls">
        <div id="global-controls">
            <h3>Simulation Settings</h3>
            <div class="control-group">
                <label>Test Particles: <span class="value-display" id="test-particles-value">50</span></label>
                <input type="range" id="test-particles" min="10" max="500" step="10" value="50">
            </div>
            <div class="control-group">
                <label>Spawn Count: <span class="value-display" id="spawn-count-value">1</span> per spawn</label>
                <input type="range" id="spawn-count" min="1" max="10" step="1" value="1">
            </div>
            <div class="control-group">
                <label>Spawn Rate: <span class="value-display" id="spawn-rate-value">Medium</span></label>
                <input type="range" id="spawn-rate" min="1" max="5" step="1" value="3">
            </div>
            <div class="control-group">
                <label>Field Strength: <span class="value-display" id="field-strength-value">1.0</span>x</label>
                <input type="range" id="field-strength" min="0.1" max="3" step="0.1" value="1">
            </div>
            <div class="control-group">
                <label>Test Particle Mass: <span class="value-display" id="test-mass-value">0.010</span></label>
                <input type="range" id="test-mass" min="0.001" max="0.1" step="0.001" value="0.01">
            </div>
            <div class="control-group">
                <label>Trail Decay Rate: <span class="value-display" id="decay-rate-value">Medium</span></label>
                <input type="range" id="decay-rate" min="1" max="5" step="1" value="3">
            </div>
            <div class="control-group">
                <label>Fog Density: <span class="value-display" id="fog-density-value">Medium</span></label>
                <input type="range" id="fog-density" min="0" max="4" step="1" value="2">
            </div>
            <div class="control-group">
                <label>Illumination: <span class="value-display" id="illumination-value">50%</span></label>
                <input type="range" id="illumination" min="0" max="100" step="5" value="50">
            </div>
            <button id="clear-test">Clear Test Particles</button>
        </div>

        <div class="section-title">Fixed Charges</div>
        <div class="control-group">
            <label>Next Charge Value: <span class="value-display" id="next-charge-value">5.0</span></label>
            <input type="range" id="next-charge" min="-10" max="10" step="0.5" value="5">
        </div>
        <button id="add-charge">Add Charge at Center</button>
        <div id="charge-controls"></div>
        <button id="clear-charges" class="danger">Clear All Charges</button>

        <button id="reset" style="margin-top: 20px;">Reset Everything</button>
    </div>
    <div id="info">
        <strong>Controls:</strong><br>
        • Ctrl+Click to place a charge in space<br>
        • Drag to rotate view | Scroll to zoom<br>
        • Particles spawn at positive charges (red)<br>
        • Particles are destroyed at negative charges (blue)
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let fixedCharges = [];
        let testParticles = [];
        let fieldLines = [];
        
        // Physics constants
        const dt = 0.008;
        let testMass = 0.01;
        const testCharge = 1.0; // Fixed at 1
        const k = 8.99; // Coulomb constant (scaled for visualization)
        
        // Control values
        let maxTestParticles = 50;
        let spawnRate = 3;
        let spawnCount = 1;
        let fieldStrength = 1.0;
        let nextChargeValue = 5.0;
        let frameCount = 0;
        let decayRate = 3; // 1=very slow, 5=very fast
        let trailSegments = []; // Global array for all trail segments
        let fogDensity = 2; // 0=none, 4=very dense
        let illumination = 50; // 0-100%
        
        // Mouse controls
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        let rotation = { x: 0.3, y: 0.5 };
        let zoom = 40;
        let raycaster = new THREE.Raycaster();
        let mouse = new THREE.Vector2();

        function updateFog() {
            const fogSettings = [
                { near: 1000, far: 1000 }, // No fog
                { near: 60, far: 100 },     // Light
                { near: 40, far: 80 },      // Medium
                { near: 25, far: 60 },      // Dense
                { near: 15, far: 40 }       // Very dense
            ];
            const setting = fogSettings[fogDensity];
            scene.fog = new THREE.Fog(0x000510, setting.near, setting.far);
        }

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);
            scene.fog = new THREE.Fog(0x000510, 30, 80);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = zoom;
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            
            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            // Create reference grid
            createGrid();
            
            // Create axes
            createAxes();
            
            // Initialize with default dipole configuration
            addFixedCharge(new THREE.Vector3(10, 0, 0), 1);
            addFixedCharge(new THREE.Vector3(-10, 0, 0), -1);
            
            // Event listeners
            setupControls();
            setupMouseControls();
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function createGrid() {
            const gridHelper = new THREE.GridHelper(40, 20, 0x444444, 0x222222);
            scene.add(gridHelper);
        }
        
        function createAxes() {
            const axisLength = 20;
            const xAxis = new THREE.ArrowHelper(
                new THREE.Vector3(1, 0, 0), 
                new THREE.Vector3(0, 0, 0), 
                axisLength, 
                0xff4444
            );
            const yAxis = new THREE.ArrowHelper(
                new THREE.Vector3(0, 1, 0), 
                new THREE.Vector3(0, 0, 0), 
                axisLength, 
                0x44ff44
            );
            const zAxis = new THREE.ArrowHelper(
                new THREE.Vector3(0, 0, 1), 
                new THREE.Vector3(0, 0, 0), 
                axisLength, 
                0x4444ff
            );
            scene.add(xAxis);
            scene.add(yAxis);
            scene.add(zAxis);
        }
        
        function addFixedCharge(position, chargeValue) {
            const isPositive = chargeValue > 0;
            const color = isPositive ? new THREE.Color(0xff4444) : new THREE.Color(0x4444ff);
            
            // Create charge sphere
            const size = Math.min(Math.abs(chargeValue) * 0.3, 3);
            const geometry = new THREE.SphereGeometry(size, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            // Glow sphere
            const glowGeometry = new THREE.SphereGeometry(size * 1.5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            
            // Point light
            const light = new THREE.PointLight(color, Math.abs(chargeValue) * 0.5, 20);
            light.position.copy(position);
            
            scene.add(mesh);
            scene.add(glow);
            scene.add(light);
            
            const charge = {
                position: position.clone(),
                value: chargeValue,
                mesh: mesh,
                glow: glow,
                light: light,
                index: fixedCharges.length
            };
            
            fixedCharges.push(charge);
            createChargeControl(charge);
            
            return charge;
        }
        
        function removeFixedCharge(index) {
            const charge = fixedCharges[index];
            if (charge) {
                scene.remove(charge.mesh);
                scene.remove(charge.glow);
                scene.remove(charge.light);
                fixedCharges.splice(index, 1);
                
                // Re-index remaining charges
                fixedCharges.forEach((c, i) => c.index = i);
                
                // Rebuild controls
                document.getElementById('charge-controls').innerHTML = '';
                fixedCharges.forEach(c => createChargeControl(c));
            }
        }
        
        function createChargeControl(charge) {
            const controlsContainer = document.getElementById('charge-controls');
            const color = charge.value > 0 ? '#ff4444' : '#4444ff';
            
            const section = document.createElement('div');
            section.className = 'charge-section';
            section.style.borderLeftColor = color;
            section.id = `charge-section-${charge.index}`;
            
            section.innerHTML = `
                <h4>
                    <span>
                        <span class="charge-indicator" style="background: ${color};"></span>
                        Charge ${charge.index + 1}
                    </span>
                    <button class="small-button danger" onclick="removeFixedCharge(${charge.index})">Remove</button>
                </h4>
                <div class="control-group">
                    <label>Charge Value: <span class="value-display" id="charge-val-${charge.index}">${charge.value.toFixed(1)}</span></label>
                    <input type="range" id="charge-value-${charge.index}" min="-10" max="10" step="0.5" value="${charge.value}">
                </div>
                <div class="control-group">
                    <label>Position</label>
                    <div class="coordinate-input">
                        <div>
                            <label>X</label>
                            <input type="number" id="charge-x-${charge.index}" value="${charge.position.x.toFixed(1)}" step="0.5">
                        </div>
                        <div>
                            <label>Y</label>
                            <input type="number" id="charge-y-${charge.index}" value="${charge.position.y.toFixed(1)}" step="0.5">
                        </div>
                        <div>
                            <label>Z</label>
                            <input type="number" id="charge-z-${charge.index}" value="${charge.position.z.toFixed(1)}" step="0.5">
                        </div>
                    </div>
                </div>
            `;
            
            controlsContainer.appendChild(section);
            
            // Add event listeners
            document.getElementById(`charge-value-${charge.index}`).addEventListener('input', (e) => {
                charge.value = parseFloat(e.target.value);
                document.getElementById(`charge-val-${charge.index}`).textContent = charge.value.toFixed(1);
                updateChargeAppearance(charge);
            });
            
            ['x', 'y', 'z'].forEach(axis => {
                document.getElementById(`charge-${axis}-${charge.index}`).addEventListener('input', (e) => {
                    charge.position[axis] = parseFloat(e.target.value);
                    charge.mesh.position.copy(charge.position);
                    charge.glow.position.copy(charge.position);
                    charge.light.position.copy(charge.position);
                });
            });
        }
        
        function updateChargeAppearance(charge) {
            const isPositive = charge.value > 0;
            const color = isPositive ? new THREE.Color(0xff4444) : new THREE.Color(0x4444ff);
            charge.glow.material.color = color;
            charge.light.color = color;
            charge.light.intensity = Math.abs(charge.value) * 0.5;
            
            // Update border color
            const section = document.getElementById(`charge-section-${charge.index}`);
            if (section) {
                section.style.borderLeftColor = isPositive ? '#ff4444' : '#4444ff';
                const indicator = section.querySelector('.charge-indicator');
                if (indicator) {
                    indicator.style.background = isPositive ? '#ff4444' : '#4444ff';
                }
            }
        }
        
        function spawnTestParticle() {
            if (testParticles.length >= maxTestParticles) return;
            
            // Find positive charges to spawn near
            const positiveCharges = fixedCharges.filter(c => c.value > 0);
            if (positiveCharges.length === 0) return; // No spawn points
            
            // Pick a random positive charge
            const sourceCharge = positiveCharges[Math.floor(Math.random() * positiveCharges.length)];
            
            // Spawn near the positive charge with some random offset
            const offset = new THREE.Vector3(
                (Math.random() - 0.5) * 3,
                (Math.random() - 0.5) * 3,
                (Math.random() - 0.5) * 3
            );
            const position = sourceCharge.position.clone().add(offset);
            
            // Small random initial velocity
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5,
                (Math.random() - 0.5) * 0.5
            );
            
            const hue = Math.random() * 60 + 150; // Blue-green range
            const color = new THREE.Color(`hsl(${hue}, 80%, 60%)`);
            
            // Calculate opacity based on illumination
            const baseOpacity = illumination / 100;
            
            // Small particle
            const geometry = new THREE.SphereGeometry(0.15, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.8 * baseOpacity
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            
            // Tiny glow
            const glowGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.3 * baseOpacity,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.copy(position);
            
            scene.add(mesh);
            scene.add(glow);
            
            testParticles.push({
                position: position,
                velocity: velocity,
                mesh: mesh,
                glow: glow,
                color: color,
                age: 0,
                baseOpacity: baseOpacity
            });
        }
        
        function calculateElectricField(position) {
            const field = new THREE.Vector3(0, 0, 0);
            
            fixedCharges.forEach(charge => {
                const r = new THREE.Vector3().subVectors(position, charge.position);
                const distance = r.length();
                
                if (distance < 0.5) return; // Avoid singularity
                
                // E = k * q / r^2 in direction of r
                const magnitude = (k * charge.value * fieldStrength) / (distance * distance);
                const direction = r.clone().normalize();
                field.add(direction.multiplyScalar(magnitude));
            });
            
            return field;
        }
        
        function addTrailSegment(position, color) {
            // Limit trail segment creation rate
            if (trailSegments.length > 4000) return;
            
            // Calculate opacity based on illumination
            const baseOpacity = illumination / 100;
            
            // Create a small sphere for each trail point
            const geometry = new THREE.SphereGeometry(0.1, 6, 6);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 1.0 * baseOpacity,
                blending: THREE.AdditiveBlending
            });
            const sphere = new THREE.Mesh(geometry, material);
            sphere.position.copy(position);
            scene.add(sphere);
            
            trailSegments.push({
                mesh: sphere,
                age: 0,
                maxAge: 100,
                baseOpacity: baseOpacity
            });
        }
        
        function updateTrailSegments() {
            // Decay rate affects how long trails last
            const decayMultiplier = [0.3, 0.5, 1.0, 1.5, 2.5][decayRate - 1];
            
            // Process in batches to avoid long single-frame operations
            const batchSize = Math.min(100, trailSegments.length);
            let processed = 0;
            
            for (let i = trailSegments.length - 1; i >= 0 && processed < batchSize; i--, processed++) {
                const segment = trailSegments[i];
                segment.age += decayMultiplier;
                
                // If segment has velocity (destruction effect), move it
                if (segment.velocity) {
                    segment.mesh.position.add(segment.velocity);
                    segment.velocity.multiplyScalar(0.95); // Slow down
                }
                
                // Fade out over time
                const lifeRatio = 1 - (segment.age / segment.maxAge);
                segment.mesh.material.opacity = Math.max(0, lifeRatio * 0.6 * segment.baseOpacity);
                segment.mesh.scale.setScalar(0.5 + lifeRatio * 0.5);
                
                // Remove when fully decayed
                if (segment.age >= segment.maxAge) {
                    segment.mesh.geometry.dispose();
                    segment.mesh.material.dispose();
                    scene.remove(segment.mesh);
                    trailSegments.splice(i, 1);
                }
            }
            
            // Emergency cleanup if too many segments
            if (trailSegments.length > 3000) {
                const excess = trailSegments.length - 2500;
                for (let i = 0; i < excess; i++) {
                    if (trailSegments[i]) {
                        trailSegments[i].mesh.geometry.dispose();
                        trailSegments[i].mesh.material.dispose();
                        scene.remove(trailSegments[i].mesh);
                    }
                }
                trailSegments.splice(0, excess);
            }
        }
        
        function updateTestParticles() {
            const negativeCharges = fixedCharges.filter(c => c.value < 0);
            
            // Limit particles processed per frame for performance
            const maxProcessPerFrame = Math.min(testParticles.length, 200);
            
            for (let i = testParticles.length - 1; i >= Math.max(0, testParticles.length - maxProcessPerFrame); i--) {
                const particle = testParticles[i];
                particle.age++;
                
                // Check if particle is near any negative charge (destruction condition)
                let shouldDestroy = false;
                for (const negCharge of negativeCharges) {
                    const distance = particle.position.distanceTo(negCharge.position);
                    if (distance < 1.5) { // Destruction radius
                        shouldDestroy = true;
                        
                        // Create destruction effect (limited)
                        if (trailSegments.length < 3500) {
                            createDestructionEffect(particle.position, particle.color);
                        }
                        break;
                    }
                }
                
                if (shouldDestroy) {
                    particle.mesh.geometry.dispose();
                    particle.mesh.material.dispose();
                    particle.glow.geometry.dispose();
                    particle.glow.material.dispose();
                    scene.remove(particle.mesh);
                    scene.remove(particle.glow);
                    testParticles.splice(i, 1);
                    continue;
                }
                
                // Calculate electric field at particle position
                const field = calculateElectricField(particle.position);
                
                // Check for NaN or infinite values
                if (!isFinite(field.x) || !isFinite(field.y) || !isFinite(field.z)) {
                    particle.mesh.geometry.dispose();
                    particle.mesh.material.dispose();
                    particle.glow.geometry.dispose();
                    particle.glow.material.dispose();
                    scene.remove(particle.mesh);
                    scene.remove(particle.glow);
                    testParticles.splice(i, 1);
                    continue;
                }
                
                // F = qE, a = F/m
                const force = field.multiplyScalar(testCharge);
                const acceleration = force.divideScalar(testMass);
                
                // Update velocity and position with safety check
                particle.velocity.add(acceleration.multiplyScalar(dt));
                
                // Limit maximum velocity to prevent instability
                const maxSpeed = 50;
                if (particle.velocity.length() > maxSpeed) {
                    particle.velocity.normalize().multiplyScalar(maxSpeed);
                }
                
                // Add damping
                particle.velocity.multiplyScalar(0.99);
                
                particle.position.add(particle.velocity.clone().multiplyScalar(dt));
                
                // Update mesh
                particle.mesh.position.copy(particle.position);
                particle.glow.position.copy(particle.position);
                
                // Add trail segment every few frames (with limits)
                if (particle.age % 4 === 0 && trailSegments.length < 4000) {
                    addTrailSegment(particle.position.clone(), particle.color);
                }
                
                // Remove if too old or too far
                if (particle.age > 1500 || particle.position.length() > 60) {
                    particle.mesh.geometry.dispose();
                    particle.mesh.material.dispose();
                    particle.glow.geometry.dispose();
                    particle.glow.material.dispose();
                    scene.remove(particle.mesh);
                    scene.remove(particle.glow);
                    testParticles.splice(i, 1);
                }
            }
            
            // Update all trail segments
            updateTrailSegments();
        }
        
        function createDestructionEffect(position, color) {
            // Calculate opacity based on illumination
            const baseOpacity = illumination / 100;
            
            // Create a burst of small particles
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const speed = 0.5;
                const offset = new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.sin(angle) * speed,
                    (Math.random() - 0.5) * speed
                );
                
                const geometry = new THREE.SphereGeometry(0.1, 6, 6);
                const material = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 1.0 * baseOpacity,
                    blending: THREE.AdditiveBlending
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(position);
                scene.add(sphere);
                
                trailSegments.push({
                    mesh: sphere,
                    age: 0,
                    maxAge: 30,
                    velocity: offset,
                    baseOpacity: baseOpacity
                });
            }
        }
        
        function setupControls() {
            // Menu toggle
            const menuToggle = document.getElementById('menu-toggle');
            const controlsPanel = document.getElementById('controls');
            let menuVisible = true;
            
            menuToggle.addEventListener('click', () => {
                menuVisible = !menuVisible;
                if (menuVisible) {
                    controlsPanel.classList.remove('hidden');
                    menuToggle.classList.remove('controls-hidden');
                    menuToggle.textContent = '☰';
                } else {
                    controlsPanel.classList.add('hidden');
                    menuToggle.classList.add('controls-hidden');
                    menuToggle.textContent = '☰';
                }
            });
            
            document.getElementById('test-particles').addEventListener('input', (e) => {
                maxTestParticles = parseInt(e.target.value);
                document.getElementById('test-particles-value').textContent = maxTestParticles;
            });
            
            document.getElementById('spawn-count').addEventListener('input', (e) => {
                spawnCount = parseInt(e.target.value);
                document.getElementById('spawn-count-value').textContent = spawnCount;
            });
            
            document.getElementById('spawn-rate').addEventListener('input', (e) => {
                spawnRate = parseInt(e.target.value);
                const rates = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Very Fast'];
                document.getElementById('spawn-rate-value').textContent = rates[spawnRate - 1];
            });
            
            document.getElementById('field-strength').addEventListener('input', (e) => {
                fieldStrength = parseFloat(e.target.value);
                document.getElementById('field-strength-value').textContent = fieldStrength.toFixed(1);
            });
            
            document.getElementById('test-mass').addEventListener('input', (e) => {
                testMass = parseFloat(e.target.value);
                document.getElementById('test-mass-value').textContent = testMass.toFixed(3);
            });
            
            document.getElementById('decay-rate').addEventListener('input', (e) => {
                decayRate = parseInt(e.target.value);
                const rates = ['Very Slow', 'Slow', 'Medium', 'Fast', 'Very Fast'];
                document.getElementById('decay-rate-value').textContent = rates[decayRate - 1];
            });
            
            document.getElementById('fog-density').addEventListener('input', (e) => {
                fogDensity = parseInt(e.target.value);
                const densities = ['None', 'Light', 'Medium', 'Dense', 'Very Dense'];
                document.getElementById('fog-density-value').textContent = densities[fogDensity];
                updateFog();
            });
            
            document.getElementById('illumination').addEventListener('input', (e) => {
                illumination = parseInt(e.target.value);
                document.getElementById('illumination-value').textContent = illumination + '%';
                
                // Update existing particles and trails
                const baseOpacity = illumination / 100;
                testParticles.forEach(particle => {
                    particle.baseOpacity = baseOpacity;
                    particle.mesh.material.opacity = 0.8 * baseOpacity;
                    particle.glow.material.opacity = 0.3 * baseOpacity;
                });
                
                trailSegments.forEach(segment => {
                    const lifeRatio = 1 - (segment.age / segment.maxAge);
                    segment.baseOpacity = baseOpacity;
                    segment.mesh.material.opacity = Math.max(0, lifeRatio * 0.6 * baseOpacity);
                });
            });
            
            document.getElementById('next-charge').addEventListener('input', (e) => {
                nextChargeValue = parseFloat(e.target.value);
                document.getElementById('next-charge-value').textContent = nextChargeValue.toFixed(1);
            });
            
            document.getElementById('add-charge').addEventListener('click', () => {
                addFixedCharge(new THREE.Vector3(0, 0, 0), nextChargeValue);
            });
            
            document.getElementById('clear-charges').addEventListener('click', () => {
                fixedCharges.forEach(charge => {
                    scene.remove(charge.mesh);
                    scene.remove(charge.glow);
                    scene.remove(charge.light);
                });
                fixedCharges = [];
                document.getElementById('charge-controls').innerHTML = '';
            });
            
            document.getElementById('clear-test').addEventListener('click', () => {
                testParticles.forEach(p => {
                    scene.remove(p.mesh);
                    scene.remove(p.glow);
                });
                testParticles = [];
                
                // Clear all trail segments
                trailSegments.forEach(segment => {
                    scene.remove(segment.mesh);
                });
                trailSegments = [];
            });
            
            document.getElementById('reset').addEventListener('click', () => {
                location.reload();
            });
        }
        
        function setupMouseControls() {
            renderer.domElement.addEventListener('mousedown', (e) => {
                if (!e.ctrlKey && !e.metaKey) {
                    isDragging = true;
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const dx = e.clientX - prevMouse.x;
                    const dy = e.clientY - prevMouse.y;
                    rotation.y += dx * 0.005;
                    rotation.x += dy * 0.005;
                    rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotation.x));
                    prevMouse = { x: e.clientX, y: e.clientY };
                }
            });
            
            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            renderer.domElement.addEventListener('click', (e) => {
                // Only place charges with Ctrl+Click or Cmd+Click (Mac)
                if (!e.ctrlKey && !e.metaKey) return;
                
                mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                
                // Create a point in space at distance 30 from camera
                const direction = new THREE.Vector3();
                raycaster.ray.direction.normalize();
                const distance = 30;
                const placePosition = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(distance));
                
                addFixedCharge(placePosition, nextChargeValue);
            });
            
            renderer.domElement.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom += e.deltaY * 0.02;
                zoom = Math.max(15, Math.min(80, zoom));
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            frameCount++;
            
            // Spawn test particles based on rate and count
            if (frameCount % (6 - spawnRate) === 0 && fixedCharges.length > 0) {
                for (let i = 0; i < spawnCount; i++) {
                    if (testParticles.length >= maxTestParticles) break;
                    spawnTestParticle();
                }
            }
            
            updateTestParticles();
            
            // Update camera
            camera.position.x = Math.cos(rotation.y) * Math.cos(rotation.x) * zoom;
            camera.position.y = Math.sin(rotation.x) * zoom;
            camera.position.z = Math.sin(rotation.y) * Math.cos(rotation.x) * zoom;
            camera.lookAt(0, 0, 0);
            
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        init();
        animate();
    </script>
</body>
</html>
